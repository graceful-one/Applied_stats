---
title: "Lab 2: Descriptive Statistics, Probability Distributions, and
Sampling"
author: "Miao Hu"
date: "2024-01-24"
output:
  pdf_document: default
---

```{r setup}
knitr::opts_knit$set(root.dir = "C:/Users/mh471/Downloads/lab02")
getwd()
```

```{r}
afdat <- read.csv("~/applied_stats/Applied_stats/Lab_2/AfrPlots.csv", header = TRUE)
```

```{r}
setwd("~/applied_stats/Applied_stats/Lab_2")
afdat <- read.csv("AfrPlots.csv", header = T)
getwd()
```

# More functions in R

In this lab, we introduce a few new R commands. 1. ls() - provides a list of all the objects in the workspace 2. rm() - removes individual objects from the workspace 3. attach() - attaches a database to the R search path, making it possible to refer to a variable in the data frame by their names alone 4. detach() - removes databases, usually a data frame that has been attached with attach or a package attached by library or require 5. is.na() - logical function that identifies all NA's within a vector, returning either TRUE or FALSE for each value 6. dbinom() - returns the height of the probability density function of the binomial distribution 7. pbinom() - returns the cumulative density function of the binomial distribution; given a number, it computes the probability that a random number from a binomial distribution will be less than that number 8. rbinom() - generates a random number from the binomial distribution defined by the probability (prob) of "successes" in a specified number (size) of trials 9. dpois(), ppois(), rpois() - Same functions as above, but for the Poisson distribution defined by a single parameter, lambda, which specifies the mean and variance of the distribution

```{r}
var0 <- seq(1:5)
#ls() - provides a list of all the objects in the workspace
ls()
```

```{r}
#rm() - removes individual objects from the workspace
rm(var0)
ls()
```

In R, missing values are represented by the symbol NA (not available). mean() have arguments to remove NA's from the operation. na.rm is.assumed to be FALSE if it is not explicitly set. is.na is a logical function, meaning that it will return a TRUE or FALSE response for each value in the vector.

```{r}
var1 <- c(0, 4, NA, 2, NA, 7)
mean(var1)
mean(var1, na.rm = TRUE) # can remove na while calculating
is.na(var1) #checks each value if NA or not 
```

```{r}
var2 <- var1[!is.na(var1)]#remove NA
var2a <- var1[is.na(var1) == FALSE]#do same thing
var2
var2a
```

```{r}
var2[var2 == 7] <- NA #can set to be NA for example if there is a problem, changes any one that where it equals 7
var2
```

```{r}
# var2 <- c(0, 4, 7, 7, 8, 7)
# 
# # Find the index of the first occurrence of 7
# index_of_first_7 <- which(var2 == 7)[1]
# #can use if there are multiple but only want one to be na
# # Check if there is at least one 7, and if so, replace the first occurrence with NA
# if (length(index_of_first_7) > 0) {
#   var2[index_of_first_7] <- NA
# }
# 
# # Check the result
# var2
```

# Exploratory data analysis in R

## Measures of location and spread

We have talked about measures of location and spread in lecture. There are several measures of central tendency, including the median, mean, trimmed mean, harmonic mean, and geometric mean. Similarly, there are several measures of spread, including variance, standard deviation, and coefficient of variation.

### Variance

The variance of a sample of data can be calculated as:

$$
s^2 = \frac{1}{n - 1} \sum_{i=1}^{n} (Y_i -\bar{Y})^2
$$

where: - $s^2$ is the sample variance. 
- $n$ is the number of observations in the sample. 
- $Y_i$ is each individual observation. 
- $\bar{Y}$ is the sample mean.

### Standard Deviation

The standard deviation is the square root of the variance:

$$
s = \sqrt{s^2}
$$

### Coefficient of Variation

The coefficient of variation is the ratio of the standard deviation to the mean, reported as a percentage:

$$
CV = \frac{s}{\bar{Y}} \times 100\%
$$

where: - $CV$ is the coefficient of variation. 
- $s$ is the standard deviation. 
- $\bar{Y}$ is the sample mean.

\*\* Exercise: Use R's functions (var, sd, mean) to find the variance, standard deviation, and coefficient of variation of BasalArea.

```{r}
sd(afdat$BasalArea)
var(afdat$BasalArea)
mean(afdat$BasalArea)
```

# Discrete probability in R

Generate some random numbers.

```{r}
sample(x = 1:100, size = 10)
```

## Binomial distribution

Bernoulli trial is an experiment with two possible outcomes

### Discrete probability function

```{r}
set.seed(1001)
sample1 <- sample(x = 1:100, size = 10)
#When you set the seed using a specific integer (like 1001), you ensure that the sequence of random numbers generated by subsequent random functions is predictable and reproducible.
sample1
set.seed(1001)
sample2 <- sample(x = 1:100, size = 10)
sample2
# sample1 and sample2 will be exactly the same because the random number generator was initialized in the same state before each sampling
# ?set.seed
# help(set.seed)
#The number 1001 itself doesn't hold any special significance over other integers; what matters is that it's used consistently to set the seed for the random number generator. 
#The seed value is crucial for reproducibility in stochastic (random) processes. 

```

Simulate a Bernoulli trial,dbinom gives the density of the binomial distribution. It gives you the probability of observing a specific number of successes in a fixed number of independent trials of a binary experiment.

```{r}
#"What is the probability of getting exactly 1 success in 1 trial of a Bernoulli process where the probability of success on each trial is 0.5?"
set.seed(1001) #just to make reproducable
dbinom(1, size=1, prob=0.5)
?dbinom
# 1,This is the number of successes(or failure). In this case, the probability is exactly 1 success(or exactly 1 failure).
# size=1: This specifies the number of trials. Here, size=1 means there is only one trial (like flipping a coin once).
# prob=0.5: This is the probability of success on each trial. Here, prob=0.5 means that the probability of success on each trial is 0.5.
```

```{r}
x <- c(0,1)
p <- c(0.3, 0.7)
plot(x, p, type = "h", las = 1, xlim = c(-0.5, 1.5),
ylim = c(0, 1), lwd = 2, col = "darkblue",
ylab = "Probability", xlab = "X")
points(x, p, pch = 16, cex = 1.2, col = "red")
```

What is the probability of obtaining 3 or fewer heads? 
Here n is the number of flips;
p is the probability of getting a heads,
x is all the possible outcomes, 
pr determines the probability of getting 0 to 10 heads out of 10 flips of a coin.

```{r}
n <- 10
p <- 1/2
x <- 0:10
pr <- dbinom(x, size = n, prob = p)
plot(x, pr, type="h",xlim = c(-1, 11), ylim = c(0, 0.5),
las = 1, lwd = 2, col = "blue",
ylab = "Probability", xlab = "Number of heads")
points(x, pr, pch = 16, cex = 1.2, col = "dark red")
```

```{r}
sum(pr[1:4])
```

```{r}
sum(dbinom(0:3, size = 10, prob = 0.5))
```

```{r}

# Binomial probability by hand
n <- 10  # number of flips
k <- 0:3   # number of successes (heads)
p <- 0.5 # probability of heads

prob.by.hand <- factorial(n) / (factorial(k) * factorial(n - k))*  p^k * (1 - p)^(n - k)
prob.by.hand
```

## Poisson probabilities

### Discrete probability function

Probability of observing a certain number of events happening in a fixed interval of time or space 
For example, if the mean number of lightening strikes on top of Mt. Baldy is 3 per year, then the probability of the mountain only being struck once in 2014 is found by: 

```{r}
dpois(x = 1, lambda = 3) # for desnisty distribution
#x: The number of events for which you want to calculate the probability.
#lambda: The average number of events in an interval (known as the rate parameter).
```

What is the probability of the mountain being struck 3 times? 10 times? 30 times?
```{r}
dpois(x = 3, lambda = 3) # 3 times
dpois(x = 10, lambda = 3) # 10 times
dpois(x = 30, lambda = 3)
```

## Normal probabilities

### Continuous probabilty function.

```{r}
dnorm(x = -1, mean = 0, sd = 1)
```

```{r}
x <- seq(-3, 3, length = 1000)
y <- dnorm(x, mean = 0, sd = 1)
plot(x, y, type = "l", lwd = 2, col = "darkblue", xlab = "X",
ylab = "Probability density", las = 1, cex.axis = 0.8, cex.lab = 0.8)
segments(-1, 0, -1, dnorm(-1, 0, 1), lwd = 2)
segments(-3, dnorm(-1, 0, 1), -1, dnorm(-1, 0, 1), lty = 2, lwd = 2)
```

```{r}
by.hand <- 1/(1*sqrt(2*pi))*exp(-(-1-0)^2/(2*1^2)) #gets the same result 
by.hand
```

```{r}
# for getting area under probability density, probability of getting a value between the two (i believe)
dnorm(x = -0.99999, mean = 0, sd = 1) - dnorm(x = -1.00001, mean = 0, sd = 1)
?dnorm
```

```{r}
pnorm(q = -1, mean = 0, sd = 1) #cumulative probability function 
?pnorm
```

```{r message=FALSE, warning=FALSE}
library(ggplot2)
library(latex2exp)

dukeblue <- "#001A57"
x1 <- seq(-4, 4, length = 1000)
xy.dat <- data.frame(cbind(x = seq(-4, 4, length = 1000),
y = dnorm(x1, mean = 0, sd = 1)))

q <- ggplot(data = xy.dat, aes(x, y)) +
  geom_line(stat = 'identity', col = dukeblue)+
  ylab("Probability density") + 
  xlab("X") +
  xlim(-4, 4) +
  annotate("text", x = 3, y = 0.38,
           label = TeX("$X \\sim \\mathrm{N}(0, 1)")) +
  theme_bw()
q

q1 <- q + stat_function(fun = dnorm, xlim = c(-4, -1), geom = "area",
                        fill = "#001A57", alpha = 0.7) +
  annotate("text", x = -3, y = 0.12,
           label = TeX("P(X$\\leq -1) = "), size = 3) +
  annotate("text", x = -3, y = 0.1,
           label = "pnorm(q = -1,", size = 3) +
  annotate("text", x = -3, y = 0.08,
           label = " mean = 0, sd = 1)", size = 3)
q1

```

## Sampling Distribution

Our experiment will consist of taking a random sample of size n = 100 from a normal population and we will compute the mean. Let's suppose that the mean of the population is 6,and the population standard deviation is 2.

In order to accomplish this, we will need to: 
1) Create a vector to store the mean we calculate from each experiment 
2) Write a for loop in R to automate each experiment 
3) Conduct the experiment within the for loop and store the results 
4) Plot the results

### Step 1: Create storage

```{r}
# Define number of experiments
nexp <- 1000
sample_means <- matrix(NA,nrow=nexp)
```

### Step 2-3: Write for loop, conduct experiment, and store results

```{r}
for (i in 1:nexp){
x <- rnorm(n=500,mean=6,sd=1)
sample_means[i] <- mean(x)
}
```

### Step 4: Plot the result

```{r}
x <- data.frame(mean_x = x)
gg <- ggplot(x,aes(mean_x))+
geom_histogram()+
geom_vline(xintercept=6,color="red")+
theme_bw()+
ggtitle("Sampling distribution of the mean")
gg
```
